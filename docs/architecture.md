# Musikkfabrikken - Architecture Document

_Author: BIP_
_Date: 2025-11-19_
_Generated by BMAD Decision Architecture Workflow v1.0_

---

## Executive Summary

Musikkfabrikken's architecture is built on **Next.js 14+ App Router** with a **mobile-first, serverless approach**. The application orchestrates AI services (OpenAI, Suno, Google) through a TypeScript-powered web platform, leveraging Supabase for backend services and implementing a pre-paid credit system for sustainable API cost management. The architecture prioritizes **Norwegian pronunciation optimization** as the core value proposition, with a **card-based UX** inspired by Spotify and TikTok patterns.

---

## Project Initialization

**First Implementation Story: Initialize Project**

Execute the following command to establish the base architecture:

```bash
npx create-next-app@latest musikkfabrikken --typescript --tailwind --app --eslint --src-dir --import-alias "@/*"
```

**What This Provides:**
- ✅ Next.js 14+ with App Router (React Server Components)
- ✅ TypeScript configured
- ✅ Tailwind CSS integrated
- ✅ ESLint with Next.js rules
- ✅ /src directory structure
- ✅ Import aliases (@/*)
- ✅ Turbopack for fast development

After initialization, install additional dependencies:
```bash
# Design System & UI
npm install @radix-ui/react-* lucide-react class-variance-authority clsx tailwind-merge

# Backend Services
npm install @supabase/supabase-js @supabase/auth-helpers-nextjs

# Payment Processing
npm install stripe @stripe/stripe-js

# AI & API Integration
npm install openai axios

# Form Management
npm install react-hook-form @hookform/resolvers zod

# Audio Player
npm install react-h5-audio-player wavesurfer.js
```

---

## Decision Summary

| Category | Decision | Version | Affects FR Categories | Rationale |
| -------- | -------- | ------- | --------------------- | --------- |
| **Framework** | Next.js App Router | 14.2+ | All | Starter template default - SSR, Server Components, optimized for mobile-first |
| **Language** | TypeScript | 5.3+ | All | Starter template default - Type safety for AI agent consistency |
| **Styling** | Tailwind CSS | 3.4+ | All | Starter template default - Matches UX spec, utility-first for rapid development |
| **Linting** | ESLint | 8.57+ | All | Starter template default - Code quality and consistency |
| **Build Tool** | Turbopack | (Next.js bundled) | All | Starter template default - Fast local development |
| **Design System** | shadcn/ui + Radix UI | Latest | User Experience & Help, All UI | UX spec selection - Accessible, customizable, Tailwind-based |

---

## Project Structure

```
musikkfabrikken/
├── .next/                          # Next.js build output (gitignored)
├── .env.local                      # Environment variables (gitignored)
├── .eslintrc.json                  # ESLint configuration
├── next.config.js                  # Next.js configuration
├── package.json                    # Dependencies
├── postcss.config.js               # PostCSS for Tailwind
├── tailwind.config.ts              # Tailwind configuration
├── tsconfig.json                   # TypeScript configuration
├── public/                         # Static assets
│   ├── images/                     # Images, icons
│   └── favicon.ico
├── src/
│   ├── app/                        # Next.js App Router
│   │   ├── layout.tsx              # Root layout (persistent across pages)
│   │   ├── page.tsx                # Home page (Create Song flow)
│   │   ├── globals.css             # Global styles + Tailwind imports
│   │   ├── api/                    # API routes (Server Actions)
│   │   │   ├── songs/              # Song generation endpoints
│   │   │   │   ├── generate/route.ts
│   │   │   │   ├── [id]/route.ts
│   │   │   │   └── webhook/route.ts
│   │   │   ├── credits/            # Credit management
│   │   │   │   ├── purchase/route.ts
│   │   │   │   └── balance/route.ts
│   │   │   ├── auth/               # Authentication callbacks
│   │   │   │   └── callback/route.ts
│   │   │   ├── canvas/             # Canvas generation
│   │   │   │   └── generate/route.ts
│   │   │   └── webhooks/           # External webhooks (Stripe, Suno)
│   │   │       ├── stripe/route.ts
│   │   │       └── suno/route.ts
│   │   ├── songs/                  # Song library page
│   │   │   ├── page.tsx
│   │   │   └── [id]/page.tsx       # Individual song detail
│   │   ├── settings/               # Settings page
│   │   │   └── page.tsx
│   │   └── auth/                   # Auth pages
│   │       ├── login/page.tsx
│   │       └── callback/page.tsx
│   ├── components/                 # React components
│   │   ├── ui/                     # shadcn/ui components
│   │   │   ├── button.tsx
│   │   │   ├── card.tsx
│   │   │   ├── input.tsx
│   │   │   ├── modal.tsx
│   │   │   ├── toast.tsx
│   │   │   └── ...
│   │   ├── genre-carousel.tsx      # Custom: Horizontal swipe genre selector
│   │   ├── phonetic-diff-viewer.tsx # Custom: Before/after lyrics comparison
│   │   ├── song-player-card.tsx    # Custom: Audio player with waveform
│   │   ├── pronunciation-toggle.tsx # Custom: Uttalelse Bokmål toggle
│   │   ├── generation-progress-modal.tsx # Custom: AI generation progress
│   │   ├── social-share-sheet.tsx  # Custom: Social media sharing
│   │   ├── bottom-navigation.tsx   # Mobile bottom nav bar
│   │   └── layout/                 # Layout components
│   │       ├── header.tsx
│   │       └── footer.tsx
│   ├── lib/                        # Utility libraries
│   │   ├── supabase/               # Supabase clients
│   │   │   ├── client.ts           # Browser client
│   │   │   ├── server.ts           # Server client
│   │   │   └── middleware.ts       # Auth middleware
│   │   ├── stripe.ts               # Stripe SDK initialization
│   │   ├── api/                    # External API integrations
│   │   │   ├── suno.ts             # Suno API wrapper
│   │   │   ├── openai.ts           # OpenAI (GPT-4) for lyrics
│   │   │   ├── google-video.ts     # Google Video API for canvas
│   │   │   └── gemini.ts           # Google Gemini for prompts
│   │   ├── phonetic/               # Norwegian pronunciation optimization
│   │   │   ├── optimizer.ts        # Core phonetic rules
│   │   │   ├── rules.ts            # Norwegian pronunciation rules
│   │   │   └── diff.ts             # Generate before/after diff
│   │   ├── credits/                # Credit system logic
│   │   │   ├── calculator.ts       # Credit cost calculations
│   │   │   ├── validator.ts        # Sufficient credits check
│   │   │   └── transaction.ts      # Atomic credit operations
│   │   ├── utils.ts                # General utilities (cn, formatDate, etc.)
│   │   └── constants.ts            # App constants (genre list, credit costs)
│   ├── types/                      # TypeScript type definitions
│   │   ├── song.ts                 # Song model types
│   │   ├── user.ts                 # User model types
│   │   ├── credit.ts               # Credit transaction types
│   │   ├── api.ts                  # API request/response types
│   │   └── supabase.ts             # Supabase generated types
│   ├── hooks/                      # Custom React hooks
│   │   ├── use-songs.ts            # Fetch user songs
│   │   ├── use-credits.ts          # Credit balance management
│   │   ├── use-audio-player.ts     # Audio playback state
│   │   └── use-toast.ts            # Toast notifications
│   └── middleware.ts               # Next.js middleware (auth protection)
└── supabase/                       # Supabase configuration
    ├── migrations/                 # Database migrations
    └── seed.sql                    # Initial data
```

---

## FR Category to Architecture Mapping

| FR Category | Component/Module | Architecture Layer |
| ----------- | ---------------- | ------------------ |
| **User Account & Authentication** (FR1-FR4) | `/src/lib/supabase/`, `/src/app/auth/`, Supabase Auth | Backend + Auth |
| **Song Creation & Lyrics Input** (FR5-FR8) | `/src/components/genre-carousel.tsx`, `/src/app/page.tsx` | Frontend |
| **Norwegian Pronunciation Optimization** (FR9-FR13) | `/src/lib/phonetic/`, `/src/components/phonetic-diff-viewer.tsx` | Core Logic + Frontend |
| **Song Generation & Processing** (FR14-FR20) | `/src/lib/api/suno.ts`, `/src/app/api/songs/generate/`, `/src/components/generation-progress-modal.tsx` | API Integration + Frontend |
| **Track List & Session Management** (FR21-FR27) | `/src/app/songs/`, `/src/components/song-player-card.tsx`, Supabase Database | Frontend + Backend |
| **Credit System & Payments** (FR28-FR34) | `/src/lib/credits/`, `/src/app/api/credits/`, `/src/lib/stripe.ts`, Stripe | Business Logic + Payment |
| **Premium Features - Canvas & Mastering** (FR35-FR45) | `/src/app/api/canvas/`, `/src/lib/api/google-video.ts`, Manual process | API Integration |
| **Storage & File Management** (FR46-FR50) | Supabase Storage, `/src/lib/supabase/storage.ts` | Backend |
| **User Experience & Help** (FR51-FR55) | `/src/components/`, shadcn/ui components | Frontend |
| **Social Sharing & Viral Features** (FR56-FR59) | `/src/components/social-share-sheet.tsx`, Native Web Share API | Frontend |
| **System Administration** (FR60-FR65) | `/src/lib/utils/logger.ts`, Supabase Dashboard, Vercel Analytics | Observability |
| **Error Handling & Resilience** (FR66-FR70) | `/src/lib/utils/error-handler.ts`, Try-catch patterns, Retry logic | Cross-cutting |

---

## Technology Stack Details

### Core Technologies

**Frontend Framework:**
- **Next.js 14.2+** with App Router
  - React Server Components for optimized performance
  - Server Actions for form submissions
  - Built-in API routes
  - Automatic code splitting

**Language:**
- **TypeScript 5.3+**
  - Strict mode enabled
  - Path aliases configured (@/*)

**Styling:**
- **Tailwind CSS 3.4+**
  - JIT mode for optimal bundle size
  - Custom theme matching Playful Nordic colors
  - Mobile-first responsive utilities

**UI Components:**
- **shadcn/ui** (Radix UI + Tailwind)
  - Accessible by default (WCAG 2.1 AA)
  - Copy-paste components (not npm dependency)
  - Full customization control

**Backend Services:**
- **Supabase** (PostgreSQL + Auth + Storage)
  - Database: PostgreSQL 15+
  - Authentication: Google OAuth
  - Storage: Audio files (MP3/WAV) + Canvas images
  - Real-time subscriptions (optional)

**Payment Processing:**
- **Stripe**
  - Checkout for credit purchases
  - Webhooks for payment confirmation
  - PCI DSS compliant

**AI & External APIs:**
- **Suno API** (via sunoapi.org wrapper) - Music generation
- **OpenAI GPT-4** - Norwegian lyric generation & phonetic optimization
- **Google Gemini** - Canvas prompt generation
- **Google Video API** - Canvas image generation

### Integration Points

**Supabase Integration:**
- **Authentication**: Google OAuth via Supabase Auth Helpers
  - Client: `@supabase/auth-helpers-nextjs` for browser
  - Server: Server-side auth in API routes and Server Components
  - Middleware: Auth state management across routes
- **Database**: PostgreSQL 17 via Supabase SDK
  - Client SDK for browser queries
  - Server SDK for API routes with RLS (Row Level Security)
- **Storage**: Supabase Storage for audio files and canvas images
  - Bucket: `songs` (audio files, 14-day retention)
  - Bucket: `canvases` (image files, 14-day retention)
  - Signed URLs for secure download

**Stripe Integration:**
- **Payments**: Stripe Checkout for credit purchases
  - Client: `@stripe/stripe-js` for Checkout redirect
  - Server: `stripe` SDK for session creation and webhook handling
- **Webhooks**: `/api/webhooks/stripe/route.ts`
  - Event types: `checkout.session.completed`, `payment_intent.succeeded`
  - Signature verification: `stripe.webhooks.constructEvent()`
  - Credit fulfillment on successful payment

**Suno API Integration:**
- **Music Generation**: Via sunoapi.org wrapper
  - Endpoint: `POST /api/custom_generate` for song creation
  - Async: Webhook callback on completion
  - Fallback: Polling if webhook fails
- **Webhook**: `/api/webhooks/suno/route.ts`
  - Receives completion notification
  - Downloads audio file to Supabase Storage
  - Updates song status in database

**OpenAI Integration:**
- **Lyric Generation**: GPT-4 for Norwegian lyrics
  - Prompt engineering for Norwegian cultural context
  - Temperature: 0.7 for creativity balance
- **Phonetic Optimization**: GPT-4 for pronunciation enhancement suggestions
  - Analyzes Norwegian text for pronunciation issues
  - Suggests phonetic spellings

**Google AI Integration:**
- **Canvas Prompts**: Gemini for AI-generated canvas descriptions
  - Input: Song metadata (title, genre, mood)
  - Output: Creative visual prompt
- **Canvas Generation**: Google Video API (experimental)
  - Input: Generated prompt
  - Output: Canvas image URL

**Web Share API:**
- **Social Sharing**: Native browser share functionality
  - Platforms: TikTok, Facebook, Instagram, WhatsApp
  - Fallback: Copy link to clipboard

---

## Implementation Patterns

**These patterns ensure consistent implementation across all AI agents working on Musikkfabrikken.**

### Language & Localization

**CRITICAL: Norwegian UI Content, English Code**

Musikkfabrikken targets Norwegian users, requiring specific language conventions:

- ✅ **User-Facing Content (Norwegian):**
  - All UI text: buttons, labels, headers, messages, tooltips
  - Error messages and notifications
  - Empty states and placeholder text
  - Date/time formatting (nb-NO locale)
  - SEO content: meta titles, descriptions
  - Email templates and user communications

- ✅ **Code & Technical (English):**
  - Variable names, function names, class names
  - File names and directory structure
  - Code comments and documentation
  - Git commit messages
  - API endpoint names and database fields
  - Internal logging and debug messages

**Examples:**
```typescript
// ✅ CORRECT: Norwegian UI, English code
function formatTransactionDate(dateString: string): string {
  // Code logic in English
  return diffMinutes <= 1 ? 'Akkurat nå' : `${diffMinutes} minutter siden`
}

<Button onClick={handlePurchase}>Kjøp kreditter</Button>

// ❌ WRONG: English UI text
<Button onClick={handlePurchase}>Purchase Credits</Button>
```

**Configuration:**
- Set in `.bmad/bmm/config.yaml`: `ui_content_language: Norwegian`
- All workflows (create-story, dev-story, etc.) must respect this setting
- Date formatting uses `nb-NO` locale: `toLocaleDateString('nb-NO')`

### Naming Conventions

**Files & Directories:**
- Components: `kebab-case.tsx` (e.g., `genre-carousel.tsx`, `song-player-card.tsx`)
- API Routes: `kebab-case/route.ts` (e.g., `/api/songs/generate/route.ts`)
- Utility files: `kebab-case.ts` (e.g., `error-handler.ts`, `logger.ts`)
- Type files: `kebab-case.ts` (e.g., `song.ts`, `credit.ts`)

**React Components:**
- PascalCase for component names: `GenreCarousel`, `SongPlayerCard`
- Props interfaces: `ComponentNameProps` (e.g., `GenreCarouselProps`)

**Functions:**
- camelCase: `generateSong()`, `optimizePronunciation()`, `validateCredits()`
- Async functions: prefix with `async` (e.g., `async function fetchSongs()`)

**Variables & Constants:**
- Variables: camelCase (`songId`, `userCredits`)
- Constants: UPPER_SNAKE_CASE (`MAX_SONG_LENGTH`, `CREDIT_COSTS`)
- Boolean variables: prefix with `is`, `has`, `should` (e.g., `isLoading`, `hasCredits`)

**Database Tables:**
- Singular, snake_case: `user`, `song`, `credit_transaction`, `genre`
- Join tables: `user_song_favorite`

**Database Columns:**
- snake_case: `user_id`, `created_at`, `song_title`, `credit_balance`
- Foreign keys: `{table}_id` (e.g., `user_id`, `song_id`)
- Timestamps: `created_at`, `updated_at`

**API Routes:**
- RESTful, plural nouns: `/api/songs`, `/api/credits`, `/api/users`
- Actions as HTTP methods (GET, POST, PUT, DELETE)
- Route parameters: `/api/songs/[id]/route.ts`

### Code Organization

**Component Structure:**
```typescript
// 1. Imports (external, then internal)
import { useState } from 'react'
import { Button } from '@/components/ui/button'

// 2. Types/Interfaces
interface SongPlayerProps {
  songId: string
}

// 3. Component
export function SongPlayer({ songId }: SongPlayerProps) {
  // 4. Hooks
  const [isPlaying, setIsPlaying] = useState(false)

  // 5. Event handlers
  const handlePlay = () => setIsPlaying(true)

  // 6. Render
  return <div>...</div>
}
```

**Test Co-location:**
- Tests live next to source: `song-player-card.tsx` + `song-player-card.test.tsx`
- Test naming: `{filename}.test.ts` or `{filename}.spec.ts`

**Barrel Exports:**
- Use index files sparingly (only for components, ui library)
- Prefer explicit imports for better tree-shaking

### API Response Format

**Success Response:**
```typescript
{
  data: T,  // The actual response payload
  meta?: {  // Optional metadata
    page?: number,
    total?: number
  }
}
```

**Error Response:**
```typescript
{
  error: {
    code: string,      // Machine-readable error code (e.g., 'INSUFFICIENT_CREDITS')
    message: string,   // User-friendly message
    details?: any      // Optional additional context
  }
}
```

**Status Codes:**
- 200: Success
- 201: Created
- 400: Bad Request (validation errors)
- 401: Unauthorized
- 403: Forbidden (insufficient credits, etc.)
- 404: Not Found
- 500: Internal Server Error

### Error Handling

**Try-Catch Pattern:**
```typescript
try {
  const result = await riskyOperation()
  return { data: result }
} catch (error) {
  console.error('Operation failed:', error)
  return { error: { code: 'OPERATION_FAILED', message: 'Friendly message' } }
}
```

**Client-Side Error Boundaries:**
- Use React Error Boundaries for component-level errors
- Toast notifications for user-facing errors
- Log errors to console + monitoring service

**API Route Error Handling:**
- All API routes return consistent error format
- Catch all exceptions, never expose internal errors
- Log full error details server-side

### State Management

**Server Components (Default):**
- Fetch data in Server Components by default
- Pass data as props to Client Components
- Use URL search params for filters/pagination

**Client State (When Needed):**
- Local state: `useState` for component-specific state
- Global lightweight state: Zustand for credit balance, auth user
- URL state: Search params for shareable state (filters, song ID)

**Zustand Store Pattern:**
```typescript
// /src/stores/credits-store.ts
import { create } from 'zustand'

interface CreditsStore {
  balance: number
  setBalance: (balance: number) => void
}

export const useCreditsStore = create<CreditsStore>((set) => ({
  balance: 0,
  setBalance: (balance) => set({ balance })
}))
```

### Database Patterns

**Row Level Security (RLS):**
- Enable RLS on all tables
- Users can only access their own data
- Service role for admin operations

**Timestamps:**
- Every table has `created_at TIMESTAMPTZ DEFAULT NOW()`
- Mutable tables add `updated_at TIMESTAMPTZ DEFAULT NOW()`

**Soft Deletes:**
- Use `deleted_at TIMESTAMPTZ` for reversible deletes
- Queries filter `WHERE deleted_at IS NULL`

**Transactions:**
- Use Supabase transactions for atomic operations (credit deduction + song creation)

### Authentication Pattern

**Middleware Protection:**
- `/src/middleware.ts` checks auth state
- Redirects unauthenticated users to `/auth/login`
- Protected routes: `/songs`, `/settings`

**Getting Current User:**
```typescript
// Server Component or API Route
import { createServerComponentClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'

const supabase = createServerComponentClient({ cookies })
const { data: { session } } = await supabase.auth.getSession()
const user = session?.user
```

### Logging Strategy

**Log Levels:**
- `ERROR`: Exceptions, failures (always log)
- `WARN`: Unexpected but handled situations
- `INFO`: Important business events (song generated, credit purchased)
- `DEBUG`: Development debugging (disabled in production)

**Log Format:**
```typescript
{
  timestamp: '2025-11-19T12:34:56Z',
  level: 'INFO',
  message: 'Song generated successfully',
  context: {
    userId: '...',
    songId: '...',
    genre: 'Country Rock'
  }
}
```

**What to Log:**
- All API calls (request/response)
- Credit transactions
- Song generation events
- Authentication events
- Errors and exceptions

### Date/Time Handling

**Storage:** Always store UTC timestamps in database (`TIMESTAMPTZ`)
**Display:** Convert to user's local timezone in UI
**Format:**
- Database: ISO 8601 (`2025-11-19T12:34:56Z`)
- API: ISO 8601 strings
- UI: Relative ("2 minutes ago") or localized ("Nov 19, 2025")

**Library:** Use native `Date` or `date-fns` for manipulation

### Credit System Patterns

**Atomic Credit Deduction:**
```typescript
// Use database transaction
await supabase.rpc('deduct_credits', {
  p_user_id: userId,
  p_amount: CREDIT_COSTS.SONG_GENERATION,
  p_description: 'Song generation'
})
```

**Rollback on Failure:**
- If Suno API fails, refund credits immediately
- Log transaction for audit trail

**Credit Costs (Constants):**
```typescript
export const CREDIT_COSTS = {
  SONG_GENERATION: 10,
  CANVAS_GENERATION: 5,
  MASTERING_SERVICE: 20,
  FREE_PREVIEW: 0  // 30-second preview
} as const
```

---

## Data Architecture

### Database Schema (PostgreSQL 17 via Supabase)

**Core Tables:**

```sql
-- Users (managed by Supabase Auth, extended with profile)
CREATE TABLE user_profile (
  id UUID PRIMARY KEY REFERENCES auth.users(id),
  display_name TEXT,
  credit_balance INTEGER DEFAULT 0 CHECK (credit_balance >= 0),
  preferences JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Songs
CREATE TABLE song (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES user_profile(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  genre TEXT NOT NULL,
  concept TEXT,  -- User's original concept/prompt
  original_lyrics TEXT,  -- Before phonetic optimization
  optimized_lyrics TEXT,  -- After phonetic optimization
  phonetic_enabled BOOLEAN DEFAULT true,
  suno_song_id TEXT,  -- Suno API song ID
  audio_url TEXT,  -- Supabase Storage URL
  duration_seconds INTEGER,
  status TEXT NOT NULL CHECK (status IN ('generating', 'completed', 'failed')),
  error_message TEXT,
  canvas_url TEXT,  -- Optional canvas image URL
  shared_count INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  deleted_at TIMESTAMPTZ  -- Soft delete (14-day retention)
);

CREATE INDEX idx_song_user_id ON song(user_id);
CREATE INDEX idx_song_status ON song(status);
CREATE INDEX idx_song_created_at ON song(created_at DESC);

-- Credit Transactions
CREATE TABLE credit_transaction (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES user_profile(id) ON DELETE CASCADE,
  amount INTEGER NOT NULL,  -- Positive for purchase, negative for deduction
  balance_after INTEGER NOT NULL,
  transaction_type TEXT NOT NULL CHECK (transaction_type IN ('purchase', 'deduction', 'refund')),
  description TEXT NOT NULL,
  stripe_session_id TEXT,  -- For purchases
  song_id UUID REFERENCES song(id) ON DELETE SET NULL,  -- For deductions/refunds
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_credit_transaction_user_id ON credit_transaction(user_id);
CREATE INDEX idx_credit_transaction_created_at ON credit_transaction(created_at DESC);

-- Genres (reference data)
CREATE TABLE genre (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT UNIQUE NOT NULL,
  display_name TEXT NOT NULL,
  description TEXT,
  emoji TEXT,
  suno_prompt_template TEXT NOT NULL,  -- e.g., "Country, rock, anthem, twangy guitar"
  sort_order INTEGER DEFAULT 0,
  is_active BOOLEAN DEFAULT true
);

-- Mastering Requests (manual service tracking)
CREATE TABLE mastering_request (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES user_profile(id) ON DELETE CASCADE,
  song_id UUID NOT NULL REFERENCES song(id) ON DELETE CASCADE,
  status TEXT NOT NULL CHECK (status IN ('pending', 'in_progress', 'completed', 'cancelled')),
  mastered_audio_url TEXT,
  notes TEXT,
  requested_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ
);

CREATE INDEX idx_mastering_request_status ON mastering_request(status);
```

**Row Level Security (RLS) Policies:**

```sql
-- Users can only read/update their own profile
ALTER TABLE user_profile ENABLE ROW LEVEL SECURITY;
CREATE POLICY user_profile_select ON user_profile FOR SELECT USING (auth.uid() = id);
CREATE POLICY user_profile_update ON user_profile FOR UPDATE USING (auth.uid() = id);

-- Users can only access their own songs
ALTER TABLE song ENABLE ROW LEVEL SECURITY;
CREATE POLICY song_select ON song FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY song_insert ON song FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY song_update ON song FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY song_delete ON song FOR DELETE USING (auth.uid() = user_id);

-- Users can only see their own credit transactions
ALTER TABLE credit_transaction ENABLE ROW LEVEL SECURITY;
CREATE POLICY credit_transaction_select ON credit_transaction FOR SELECT USING (auth.uid() = user_id);
```

**Database Functions (Stored Procedures):**

```sql
-- Atomic credit deduction with validation
CREATE OR REPLACE FUNCTION deduct_credits(
  p_user_id UUID,
  p_amount INTEGER,
  p_description TEXT,
  p_song_id UUID DEFAULT NULL
) RETURNS credit_transaction AS $$
DECLARE
  v_current_balance INTEGER;
  v_new_balance INTEGER;
  v_transaction credit_transaction;
BEGIN
  -- Lock user profile row
  SELECT credit_balance INTO v_current_balance
  FROM user_profile
  WHERE id = p_user_id
  FOR UPDATE;

  -- Validate sufficient credits
  IF v_current_balance < p_amount THEN
    RAISE EXCEPTION 'Insufficient credits: have %, need %', v_current_balance, p_amount;
  END IF;

  -- Calculate new balance
  v_new_balance := v_current_balance - p_amount;

  -- Update user balance
  UPDATE user_profile
  SET credit_balance = v_new_balance,
      updated_at = NOW()
  WHERE id = p_user_id;

  -- Record transaction
  INSERT INTO credit_transaction (user_id, amount, balance_after, transaction_type, description, song_id)
  VALUES (p_user_id, -p_amount, v_new_balance, 'deduction', p_description, p_song_id)
  RETURNING * INTO v_transaction;

  RETURN v_transaction;
END;
$$ LANGUAGE plpgsql;
```

---

## API Contracts

### Song Generation API

**POST `/api/songs/generate`**

Request:
```typescript
{
  genre: string,          // Genre ID or name
  concept: string,        // User's song concept (1-2 sentences)
  phoneticEnabled: boolean,  // Apply Norwegian pronunciation optimization
  title?: string          // Optional custom title
}
```

Response (202 Accepted):
```typescript
{
  data: {
    songId: string,       // UUID for tracking
    status: 'generating',
    estimatedTime: number // Seconds (120-180)
  }
}
```

**GET `/api/songs/[id]`**

Response:
```typescript
{
  data: {
    id: string,
    title: string,
    genre: string,
    audioUrl: string | null,
    status: 'generating' | 'completed' | 'failed',
    duration: number,
    createdAt: string,
    originalLyrics?: string,
    optimizedLyrics?: string,
    canvasUrl?: string
  }
}
```

### Credit Management API

**GET `/api/credits/balance`**

Response:
```typescript
{
  data: {
    balance: number,
    transactions: Array<{
      id: string,
      amount: number,
      type: 'purchase' | 'deduction' | 'refund',
      description: string,
      createdAt: string
    }>
  }
}
```

**POST `/api/credits/purchase`**

Request:
```typescript
{
  packageId: 'starter' | 'pro' | 'premium'
}
```

Response:
```typescript
{
  data: {
    checkoutUrl: string  // Stripe Checkout URL
  }
}
```

### Webhook Endpoints

**POST `/api/webhooks/stripe`**
- Handles Stripe events (checkout.session.completed)
- Verifies signature with `stripe.webhooks.constructEvent()`
- Adds credits to user account

**POST `/api/webhooks/suno`**
- Receives Suno song completion notification
- Downloads audio file to Supabase Storage
- Updates song status in database

---

## Security Architecture

### Authentication & Authorization

**Google OAuth via Supabase:**
- Single sign-on (SSO) with Google accounts
- No password management required
- JWT tokens stored in HTTP-only cookies
- Automatic token refresh

**Row Level Security (RLS):**
- PostgreSQL RLS enforces data isolation
- Users can only access their own data
- Server-side queries use user's JWT

**API Key Protection:**
- All API keys stored in environment variables
- Never exposed to client
- Separate keys for development/production

### Data Protection

**GDPR Compliance:**
- User can export all data (songs, transactions)
- User can request account deletion
- 14-day soft delete for songs (recovery window)
- Privacy policy and terms of service required

**PCI Compliance:**
- Stripe handles all payment data (PCI DSS compliant)
- No credit card data stored in app database

**File Access Security:**
- Supabase Storage with signed URLs
- Expiring URLs (24-hour validity)
- No public file access

### Input Validation

**Client-Side:**
- Form validation with React Hook Form + Zod schemas
- Type-safe inputs

**Server-Side:**
- All API inputs validated with Zod
- Sanitize user-generated content (lyrics, titles)
- Rate limiting on API routes (10 requests/minute per user)

### Secrets Management

**Environment Variables:**
```bash
# Supabase
NEXT_PUBLIC_SUPABASE_URL=...
NEXT_PUBLIC_SUPABASE_ANON_KEY=...
SUPABASE_SERVICE_ROLE_KEY=...  # Server-side only

# Stripe
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=...
STRIPE_SECRET_KEY=...  # Server-side only
STRIPE_WEBHOOK_SECRET=...  # Server-side only

# AI APIs
OPENAI_API_KEY=...  # Server-side only
GOOGLE_AI_API_KEY=...  # Server-side only
SUNO_API_KEY=...  # Server-side only
```

---

## Performance Considerations

### Frontend Performance

**Code Splitting:**
- Automatic route-based code splitting (Next.js default)
- Dynamic imports for heavy components (audio player, waveform)

**Image Optimization:**
- Next.js Image component for optimized loading
- WebP format with fallbacks
- Lazy loading for below-the-fold images

**Caching:**
- Static pages cached at CDN edge (Vercel)
- API responses cached with `cache: 'force-cache'` where appropriate
- SWR for client-side data caching

**Mobile Optimization:**
- Mobile-first CSS (Tailwind)
- Touch-friendly 48px+ tap targets
- Reduced motion for accessibility

### Backend Performance

**Database Optimization:**
- Indexed columns (user_id, created_at, status)
- Connection pooling (Supabase default)
- Prepared statements for common queries

**API Response Times:**
- Target <500ms for data queries
- Async operations (song generation) use webhooks/polling
- Edge functions for auth checks (fast worldwide)

**File Storage:**
- Supabase Storage with CDN
- Audio files compressed (MP3 ~128kbps)
- Automatic 14-day cleanup (reduce storage costs)

---

## Deployment Architecture

**Hosting:** Vercel (seamless Next.js integration)

**Regions:**
- Primary: US/EU (closest to Supabase region)
- Edge Functions: Global (auth, API routes)

**CI/CD:**
- Git push to `main` → Automatic deployment
- Preview deployments for PRs
- Rollback capability

**Environment:**
- **Production**: `main` branch → musikkfabrikken.no
- **Staging**: `staging` branch → staging.musikkfabrikken.no
- **Development**: Local

**Monitoring:**
- Vercel Analytics for performance
- Supabase Dashboard for database metrics
- Console logs → Vercel Logs
- Error tracking: Sentry (optional)

---

## Development Environment

### Prerequisites

- **Node.js**: 18.17+ or 20.x (LTS)
- **npm**: 9.x+ or pnpm 8.x+
- **Git**: 2.x+
- **Supabase CLI** (optional): For local development

### Setup Commands

```bash
# 1. Initialize project
npx create-next-app@latest musikkfabrikken --typescript --tailwind --app --eslint --src-dir --import-alias "@/*"

cd musikkfabrikken

# 2. Install additional dependencies
npm install @supabase/supabase-js @supabase/auth-helpers-nextjs stripe @stripe/stripe-js openai axios react-hook-form @hookform/resolvers zod zustand date-fns

# 3. Install shadcn/ui (interactive)
npx shadcn-ui@latest init

# 4. Add shadcn/ui components as needed
npx shadcn-ui@latest add button card input modal toast

# 5. Set up environment variables
cp .env.example .env.local
# Edit .env.local with your API keys

# 6. Run development server
npm run dev
# Visit http://localhost:3000

# 7. Run type checking
npm run type-check

# 8. Run linting
npm run lint
```

### Local Development with Supabase

```bash
# Start local Supabase (optional)
npx supabase start

# Run migrations
npx supabase db push

# Generate TypeScript types from database
npx supabase gen types typescript --local > src/types/supabase.ts
```

---

## Architecture Decision Records (ADRs)

### ADR-001: Use create-next-app Starter Template

**Status:** ✅ Accepted

**Context:** Need to establish base project architecture for Musikkfabrikken web application.

**Decision:** Use official create-next-app starter with TypeScript, Tailwind, and App Router.

**Consequences:**
- ✅ Fast project initialization
- ✅ Battle-tested defaults from Vercel
- ✅ Automatic updates via Next.js releases
- ✅ Matches PRD requirements (Next.js 14+, TypeScript, Tailwind)
- ✅ Community support and documentation
- ⚠️ Must add Supabase, shadcn/ui, and other dependencies manually

**Alternatives Considered:**
- Manual setup from scratch (rejected - too time-consuming, error-prone)
- T3 Stack (rejected - includes tRPC which we don't need)

---

### ADR-002: Use Supabase for Backend Services

**Status:** ✅ Accepted

**Context:** Need managed PostgreSQL database, authentication, and file storage for Norwegian song platform.

**Decision:** Use Supabase (PostgreSQL 17 + Auth + Storage) instead of building custom backend.

**Rationale:**
- All-in-one solution (database, auth, storage)
- PostgreSQL with Row Level Security
- Google OAuth built-in
- Generous free tier, scales predictably
- Next.js integration via official auth helpers

**Consequences:**
- ✅ No backend infrastructure to manage
- ✅ RLS ensures data isolation by default
- ✅ Real-time subscriptions available (future use)
- ✅ Automatic backups
- ⚠️ Vendor lock-in (but PostgreSQL is portable)
- ⚠️ Cold starts on free tier

**Alternatives Considered:**
- Firebase (rejected - document DB not ideal for relational data)
- Planetscale (rejected - no auth or storage)
- Custom Node.js backend (rejected - increases complexity)

---

### ADR-003: Use Zustand for Client-Side State Management

**Status:** ✅ Accepted

**Context:** Need lightweight global state for credit balance and auth user in Next.js App Router.

**Decision:** Use Zustand for minimal global state, prefer Server Components for data fetching.

**Rationale:**
- Tiny bundle size (~1KB gzipped)
- Simple API, no boilerplate
- Works seamlessly with React Server Components
- Only use for truly global state (credit balance, current user)
- URL params for sharable state (filters, song ID)

**Consequences:**
- ✅ Minimal client-side JavaScript
- ✅ Easy to understand and maintain
- ✅ No Provider hell
- ✅ TypeScript-first
- ⚠️ Not as feature-rich as Redux (but we don't need it)

**Alternatives Considered:**
- Redux Toolkit (rejected - overkill for simple state needs)
- Context API (rejected - re-render issues, verbose)
- Jotai/Recoil (rejected - similar to Zustand but less popular)

---

### ADR-004: Use shadcn/ui for UI Components

**Status:** ✅ Accepted

**Context:** Need accessible, customizable UI components that match UX design system.

**Decision:** Use shadcn/ui (Radix UI + Tailwind) as specified in UX design document.

**Rationale:**
- Copy-paste approach (not npm dependency) - full control
- Built on Radix UI (accessible primitives)
- Tailwind styling matches tech stack
- WCAG 2.1 AA compliant by default
- UX designer specified this in UX spec

**Consequences:**
- ✅ Full customization control
- ✅ Accessibility built-in
- ✅ Matches Tailwind styling approach
- ✅ No version dependency conflicts
- ⚠️ Must manually update components (copy new versions)

**Alternatives Considered:**
- Material UI (rejected - heavy bundle, opinionated styling)
- Chakra UI (rejected - CSS-in-JS approach doesn't match Tailwind)
- Headless UI (rejected - less comprehensive than Radix)

---

### ADR-005: Pre-Paid Credit System for API Cost Management

**Status:** ✅ Accepted

**Context:** Suno API costs $0.06/song, OpenAI ~$0.03/request - need sustainable monetization.

**Decision:** Implement pre-paid credit packages (Starter $15, Pro $45, Premium $99) instead of pay-per-song or subscription.

**Rationale:**
- Revenue collected upfront buffers API costs
- Users understand costs before generation
- Prevents bill shock (unlike pay-per-use)
- Atomic credit deduction with rollback on failure
- 14-day retention reduces storage costs

**Consequences:**
- ✅ Positive cash flow (revenue before API costs)
- ✅ Predictable user costs
- ✅ Economic resilience if APIs increase pricing
- ⚠️ Users may feel "nickel and dimed"
- ⚠️ Refund policy required for unused credits

**Alternatives Considered:**
- Subscription model (rejected - unpredictable API costs per user)
- Pay-per-song (rejected - poor UX, payment friction)
- Free with ads (rejected - not viable for Norwegian market size)

---

### ADR-006: Norwegian Pronunciation Optimization via GPT-4

**Status:** ✅ Accepted

**Context:** Core value prop is authentic Norwegian pronunciation - Suno alone produces "American-sounding" vocals.

**Decision:** Use GPT-4 to analyze Norwegian lyrics and suggest phonetic spellings before sending to Suno.

**Rationale:**
- GPT-4 understands Norwegian language nuances
- Can apply phonetic rules validated by founder (80k listener expertise)
- Visual diff preview shows before/after changes
- User can override per-line for edge cases (place names, proper nouns)
- Cost ~$0.03/request is acceptable

**Consequences:**
- ✅ Core differentiator implemented
- ✅ User transparency (visual diff)
- ✅ Flexibility (per-line override)
- ✅ Scales with GPT-4 improvements
- ⚠️ Dependent on OpenAI API availability
- ⚠️ Must monitor for quality regression

**Alternatives Considered:**
- Rule-based phonetic engine (rejected - too brittle, hard to maintain)
- Manual phonetic input only (rejected - bad UX for amateurs)
- No optimization (rejected - loses core value proposition)

---

### ADR-007: Async Song Generation with Webhook + Polling Fallback

**Status:** ✅ Accepted

**Context:** Suno API takes 1-3 minutes to generate songs - can't block HTTP request.

**Decision:** Implement async generation with webhook callback + polling fallback.

**Pattern:**
1. POST `/api/songs/generate` returns 202 Accepted with song ID
2. Client polls GET `/api/songs/[id]` every 5 seconds
3. Suno webhook notifies `/api/webhooks/suno` on completion
4. Webhook downloads audio to Supabase Storage, updates DB
5. Client poll receives 'completed' status

**Rationale:**
- Non-blocking UX (user can wait or navigate away)
- Webhook is efficient (no unnecessary polling)
- Polling fallback ensures reliability if webhook fails
- Progress modal shows estimated time (1-3 minutes)

**Consequences:**
- ✅ Resilient to webhook failures
- ✅ Good UX (progress indication)
- ✅ Efficient (webhook preferred, polling backup)
- ⚠️ Must secure webhook endpoint (signature verification)
- ⚠️ Database updates from webhook must be idempotent

**Alternatives Considered:**
- Polling only (rejected - inefficient, delays)
- Webhook only (rejected - unreliable if webhook fails)
- WebSocket (rejected - adds complexity, connection management issues)

---

### ADR-008: Stripe Checkout for Payment Processing

**Status:** ✅ Accepted

**Context:** Need PCI-compliant payment processing for credit purchases.

**Decision:** Use Stripe Checkout (hosted payment page) instead of Stripe Elements (custom form).

**Rationale:**
- PCI compliance handled by Stripe (no card data touches our servers)
- Supports multiple payment methods (card, Apple Pay, Google Pay)
- Mobile-optimized checkout flow
- Webhook for payment confirmation (secure, reliable)
- Stripe handles 3D Secure, fraud detection

**Consequences:**
- ✅ No PCI compliance burden
- ✅ Mobile-friendly payment flow
- ✅ Multiple payment methods
- ✅ Fraud protection included
- ⚠️ Redirect UX (leaves app briefly)
- ⚠️ Less UI customization than Elements

**Alternatives Considered:**
- Stripe Elements (rejected - custom form requires PCI compliance work)
- PayPal (rejected - poor mobile UX in Norway)
- Vipps (deferred to post-MVP - Norwegian payment method)

---

## Summary

### Architecture Completion

✅ **Complete architecture document created for Musikkfabrikken**

**What Was Decided:**

**Technology Stack:**
- Framework: Next.js 14+ (App Router, TypeScript, Tailwind CSS)
- Backend: Supabase (PostgreSQL 17, Auth, Storage)
- UI: shadcn/ui + Radix UI
- State: Zustand (lightweight global state)
- Payments: Stripe Checkout
- AI: OpenAI GPT-4, Suno API, Google Gemini/Video
- Deployment: Vercel

**Key Architectural Patterns:**
- Mobile-first responsive design
- Server Components by default, Client Components only when needed
- Row Level Security (RLS) for data isolation
- Pre-paid credit system with atomic transactions
- Async song generation (webhook + polling)
- Norwegian pronunciation optimization via GPT-4
- 14-day soft delete for cost management

**Database Schema:**
- 5 core tables (user_profile, song, credit_transaction, genre, mastering_request)
- RLS policies for multi-tenant data isolation
- Stored procedure for atomic credit deduction

**Implementation Consistency:**
- Comprehensive naming conventions (files, components, database, API)
- API response format standardized
- Error handling patterns
- State management strategy
- Logging format and levels
- Authentication patterns

**8 Architecture Decision Records (ADRs):**
1. create-next-app starter template
2. Supabase for backend services
3. Zustand for client state
4. shadcn/ui for UI components
5. Pre-paid credit system
6. GPT-4 pronunciation optimization
7. Async generation with webhook + polling
8. Stripe Checkout for payments

---

### Next Steps

**Immediate:**
1. **Initialize Project** - Run create-next-app command (first implementation story)
2. **Set Up Supabase** - Create project, configure auth, set up database
3. **Install Dependencies** - shadcn/ui, Supabase SDK, Stripe, OpenAI
4. **Create Epic Breakdown** - Break down 70 functional requirements into implementable stories

**Recommended Workflow:**
```
/bmad:bmm:workflows:create-epics-and-stories
```

This will create epics and stories with full context from:
- ✅ PRD (70 functional requirements)
- ✅ UX Design (mobile-first, component specs, user journeys)
- ✅ Architecture (this document - tech stack, patterns, database schema)

---

_Architecture document complete! Ready for epic breakdown and implementation._

_Generated by BMAD Decision Architecture Workflow v1.0_
_Date: 2025-11-19_
_For: BIP_
_Project: Musikkfabrikken_
